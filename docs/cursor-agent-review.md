# Отчет об организации цикла подагента CursorAgent

## Как устроен текущий цикл
- Основной системный промпт для Command Agent заставляет модель пользоваться `run_cursor_agent` как инструментом поиска по книге, предпочитая прямой курсор и режим «первого совпадения», но конкретные параметры курсора сейчас жёстко зашиты в тексте промпта, а не в вызове функции.【F:src/AiTextEditor.Lib/Services/SemanticKernel/SemanticKernelEngine.cs†L73-L104】
- Внутри `CursorAgentRuntime` каждое сообщение к подагенту собирается заново: системный промпт со схемой JSON-ответа, текстовое описание задачи и два пользовательских сообщения — слепок состояния и JSON-пакет текущей порции курсора.【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L149-L179】【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L391-L492】
- Состояние хранится в `TaskState`, нормализуется при запуске, а позиция курсора восстанавливается только через последний seen-пойнтер (startAfterPointer). Содержимое найденных совпадений остаётся в `state.Evidence`, но его текст не включается в промпт.【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L51-L131】【F:src/AiTextEditor.Lib/Services/SemanticKernel/TaskState.cs†L1-L63】

## Что передаётся между итерациями
- Snapshot-сообщение содержит только счётчики (evidence/seen), короткий `progress` и лимиты, но не перечисляет сами evidence или хвост seen-пойнтеров.【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L416-L427】
- Batch JSON отдаёт только текущую порцию курсора без связи с предыдущими шагами; подагент не видит, что уже находил в прошлых шагах.【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L391-L415】
- Поле `needMoreContext` парсится из ответа, но ни в промпте, ни в логике цикла не используется, поэтому модель не может запросить дополнительную память даже если ей это нужно.【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L541-L604】
- Лимит на новые evidence в шаге (max 3) и общий `maxFound` остаются численными, без передачи фактических фрагментов; `SnapshotEvidenceLimit` объявлен, но не задействован для свёртки истории.【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L391-L455】【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L17-L25】

## Ограничения, влияющие на запросы вида «найди…»
- Для задач на поиск нескольких точек (несколько диалогов или запутанных глав) подагент теряет контекст ранее найденных элементов: прогресс в состоянии не несёт содержимого, а evidence не показывается. Модель не может сравнивать найденные фрагменты между собой и не знает, что уже добавлено в `targetSet` или Evidence-лист.【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L416-L455】【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L264-L333】
- В тестах видны более сложные сценарии (поиск диалогов, неоднократных упоминаний), но промпт подагента жёстко заточен под «прочитай батч → сразу реши, закончили ли мы». Нет шага для уточнений или запроса допданных, поэтому маловероятно, что модель корректно соберёт цепочку похожих глав или диалогов по нескольким батчам.【F:tests/AiTextEditor.Domain.Tests/Functional/McpFunctionalTests.cs†L20-L63】
- System-подсказка Command Agent советует использовать `FirstMatch`, но API плагина не принимает режим/направление; курсор всегда идёт вперёд и не знает о разных стратегиях сбора. Это усложняет реализацию поисков вроде «самый запутанный диалог» или «первые N упоминаний», где может потребоваться иной лимит или обратный обход.【F:src/AiTextEditor.Lib/Services/SemanticKernel/SemanticKernelEngine.cs†L73-L104】【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L43-L131】

## Идеи улучшения промптов и переноса данных
1. **Явно передавать предыдущие evidence.** Добавлять в snapshot компактный JSON с последними N найденными фрагментами (`pointer`, короткий `excerpt`, причина), используя `SnapshotEvidenceLimit` как ограничитель. Это позволит модели сопоставлять новые совпадения с уже найденными и избегать повторов, сохраняя токены под контролем.【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L17-L25】【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L416-L455】
2. **Перенести переносимую память в tool-ответ.** Вместо текстовых bullet-списков выдавать snapshot как результат «виртуального» инструмента (`cursor_state`), который вызывается перед чтением батча. Это отделит инструкции от данных, улучшит структурность и позволит динамически отключать тяжёлые поля (например, excerpts) без переписывания системного промпта.【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L149-L179】
3. **Давать модели рычаг «запросить ещё память».** Использовать уже парсимое поле `needMoreContext`: если модель ставит его в `true`, рантайм может отвечать отдельным tool-вызовом с расширенной историей (список evidence, последние N seen-пойнтеров, промежуточная сводка). Так данные будут приходить только при необходимости, а базовый шаг останется лёгким.【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L541-L604】
4. **Разделить режимы задачи в промпте.** Добавить в текст задачи (или параметры функции) явный `mode`/`strategy`: `first_match`, `collect_many`, `aggregate_summary`, `backward_scan`. Тогда подагент сможет менять правило останова и ожидания по evidence под конкретный пользовательский запрос, а главный промпт перестанет противоречить API.【F:src/AiTextEditor.Lib/Services/SemanticKernel/SemanticKernelEngine.cs†L73-L104】【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L429-L455】
5. **Структурировать инструкцию по извлечению.** Переупорядочить `taskDefinitionPrompt`, убрав дубли и подчёркивая критерии матчинга (пример: «диалог = >=2 реплики с тире подряд», «запутанная глава = много местоимений/сцены сменяются»), чтобы подагент мог стабильно решать более сложные запросы, не полагаясь на догадки. Текущие инструкции описывают только механику шага, но не помогают интерпретировать цель и сравнивать батчи между собой.【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L429-L455】
6. **Дать возможность управлять шагами извне.** Воспользоваться `TaskState.Update`/`maxSteps` для явного «продолжить после pointer X» или «увеличить лимит maxFound», чтобы основной агент мог настраивать проход под конкретные пользовательские сценарии (например, поиск всех диалогов). Сейчас `progress` принимает только короткие ярлыки, что не даёт подагенту гибкости в изменении траектории поиска между итерациями.【F:src/AiTextEditor.Lib/Services/SemanticKernel/CursorAgentRuntime.cs†L247-L333】【F:src/AiTextEditor.Lib/Services/SemanticKernel/TaskState.cs†L1-L63】

## Ответ на вопрос о tool-сообщениях
Перенос промежуточных данных из текста промпта в tool-ответы имеет смысл, если:
- нужно отделить инструкции (системный промпт) от фактов (history/evidence) и снизить риск их смешения;
- объём переносимой памяти может расти (списки совпадений), и хочется выдавать их только по запросу модели (`needMoreContext` → вернули дополнительную память отдельным tool-вызовом);
- планируется использовать auto-invoke: tool-сообщение делает историю прозрачной для ядра SK и упрощает логику повторных шагов.

Для коротких задач вроде «первое упоминание» проще всегда включать компактный state-снимок прямо в сообщение — так меньше шагов в диалоге. Для сложных поисков (подборка диалогов, сравнение запутанных глав) полезно дать LLM выбор: базовый лёгкий snapshot каждый шаг + дополнительная память через tool по запросу.
