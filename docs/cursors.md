# Концепция курсоров

Курсор — именованный поток элементов `LinearDocument`, предназначенный для постраничного обхода длинного текста. Состояние курсора (позиция, параметры порции) живёт в `DocumentContext`, поэтому одна сессия может держать несколько независимых курсоров.

## Параметры курсора
* **Имя** — строковый идентификатор, например `CUR_WHOLE_BOOK_FORWARD`, `CUR_PEARSON_SEARCH`, `CUR_IMAGES`.
* **Лимиты порции** — максимум элементов и максимум размера в байтах. Элементы группируются, пока не будет достигнут один из лимитов, но порция всегда содержит хотя бы один элемент.
* **Включение текста** — флаг, определяющий, отдавать ли курсор полнотекстовые элементы или только метаданные (`Markdown`/`Text` обнуляются).
* **Направление** — вперёд или назад по документу.

По умолчанию создаются два курсора полной книги: `CUR_WHOLE_BOOK_FORWARD` и `CUR_WHOLE_BOOK_BACKWARD` с параметрами `20` элементов, `2048` байт и включённым текстом. Их состояние всегда можно сбросить через `CursorContext.EnsureWholeBookForward/Backward`, что создаёт новую итерацию с теми же именами.

## Структура порции
`CursorContext.GetNextPortion` возвращает `CursorPortion` с именем курсора, списком элементов и флагом `HasMore`. Размер порции ограничен лимитами, но если элемент больше лимита, он всё равно будет отдан один в отдельной порции. Для курсоров без текста `Markdown` и `Text` элементов будут пустыми.

## Управление курсорами
`CursorContext` отвечает за создание и продвижение курсоров. Высокоуровневые методы:
- `CreateCursor(name, parameters, direction)` — создаёт или переинициализирует курсор с указанными параметрами и началом в начале/конце документа.
- `EnsureWholeBookForward/EnsureWholeBookBackward` — сбрасывают дефолтные курсоры полного прохода.
- `GetNextPortion(cursorName)` — выдаёт очередную порцию и продвигает курсор.

Состояние хранится в рамках `DocumentContext`, поэтому разные плагины могут обращаться к своим курсорам, не мешая друг другу.

## execute_query_over_cursor
Общий исполнитель запросов — `CursorQueryExecutor.ExecuteQueryOverCursorAsync(cursorName, query)`:
1. Создаёт отдельный `ChatHistory` с системной инструкцией обрабатывать поступающие порции и отвечать JSON с полями `status` (`found`, `continue`, `complete`) и `result`.
2. Итеративно берёт порции курсора, формирует промпт с задачей и элементами порции, отправляет в LLM и парсит ответ.
3. Завершает обход при статусах `found` или `complete` либо при исчерпании курсора. Возвращает `CursorQueryResult` с флагом успеха и полезной нагрузкой (например, семантическим указателем).

Функция универсальна: её можно использовать для поиска, фильтрации, суммаризации и других сканирующих сценариев — достаточно задать нужный текст запроса.

## Пример использования
Поиск первого совпадения через `NavigationPlugin.FindFirst`:
```csharp
var parameters = new CursorParameters(20, 2048, includeText: true);
var cursorName = documentContext.CursorContext.EnsureWholeBookForward(parameters);
var result = await cursorQueryExecutor.ExecuteQueryOverCursorAsync(cursorName,
    "Locate the first mention of Ada Lovelace and return its semantic pointer.");
var pointer = result.Success ? result.Result : "Not found";
```

Благодаря курсору запрос идёт пакетами, не загружая целую книгу в память LLM.
