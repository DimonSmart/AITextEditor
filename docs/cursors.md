# Концепция курсоров

Курсор — именованный поток элементов `LinearDocument`, предназначенный для постраничного обхода длинного текста. Состояние курсора (позиция, параметры порции) живёт в `DocumentContext`, поэтому одна сессия может держать несколько независимых курсоров.

## Параметры курсора
* **Имя** — строковый идентификатор, например `CUR_WHOLE_BOOK_FORWARD`, `CUR_PEARSON_SEARCH`, `CUR_IMAGES`.
* **Лимиты порции** — максимум элементов и максимум размера в байтах. Элементы группируются, пока не будет достигнут один из лимитов, но порция всегда содержит хотя бы один элемент.
* **Включение текста** — флаг, определяющий, отдавать ли курсор полнотекстовые элементы или только метаданные (`Markdown`/`Text` обнуляются).
* **Направление** — вперёд или назад по документу.

По умолчанию создаются два курсора полной книги: `CUR_WHOLE_BOOK_FORWARD` и `CUR_WHOLE_BOOK_BACKWARD` с параметрами `20` элементов, `2048` байт и включённым текстом. Их состояние всегда можно сбросить через `CursorContext.EnsureWholeBookForward/Backward`, что создаёт новую итерацию с теми же именами.

## Структура порции
`CursorContext.GetNextPortion` возвращает `CursorPortion` с именем курсора, списком элементов и флагом `HasMore`. Размер порции ограничен лимитами, но если элемент больше лимита, он всё равно будет отдан один в отдельной порции. Для курсоров без текста `Markdown` и `Text` элементов будут пустыми.

## Управление курсорами
`CursorContext` отвечает за создание и продвижение курсоров. Высокоуровневые методы:
- `CreateCursor(name, parameters, forward)` — создаёт или переинициализирует курсор с указанными параметрами и выбором направления (`true` — от начала к концу, `false` — от конца к началу).
- `EnsureWholeBookForward/EnsureWholeBookBackward` — сбрасывают дефолтные курсоры полного прохода.
- `GetNextPortion(cursorName)` — выдаёт очередную порцию и продвигает курсор.

Состояние хранится в рамках `DocumentContext`, поэтому разные плагины могут обращаться к своим курсорам, не мешая друг другу.

## execute_query_over_cursor
Общий исполнитель запросов — `CursorQueryExecutor.ExecuteQueryOverCursorAsync(cursorName, query)`:
1. Создаёт отдельный `ChatHistory` с системной инструкцией обрабатывать поступающие порции и отвечать JSON с полями `status` (`found`, `continue`, `complete`) и `result`.
2. Итеративно берёт порции курсора, формирует промпт с задачей и элементами порции, отправляет в LLM и парсит ответ.
3. Завершает обход при статусах `found` или `complete` либо при исчерпании курсора. Возвращает `CursorQueryResult` с флагом успеха и полезной нагрузкой (например, семантическим указателем).

Функция универсальна: её можно использовать для поиска, фильтрации, суммаризации и других сканирующих сценариев — достаточно задать нужный текст запроса.

## Плагин навигации для LLM
`NavigationPlugin` предоставляет функции, которые позволяют LLM создавать/сбрасывать курсоры, читать порции и запускать задачные запросы поверх курсора:
- `CreateCursor` — создать или переинициализировать именованный курсор с лимитами и направлением.
- `UseWholeBookCursor` — сбросить курсор для полной книги с заданными лимитами.
- `GetNextPortion` — получить следующую порцию в виде компактного JSON с флагом `hasMore` и сериализованными семантическими указателями.
- `QueryCursor` — выполнить инструкцию поверх курсора через `CursorQueryExecutor` и вернуть JSON с результатом (`success` + `result`).
- `MapCursor` — применить инструкцию к каждой порции по отдельности и вернуть массив JSON-результатов по индексу порции (для map/reduce сценариев).
- `DescribePointer` — расшифровка сериализованного семантического указателя.

Возвращаемые значения сериализованы в JSON с `camelCase`, поэтому их удобно парсить в агентах или прокидывать в новые вызовы.

`CursorHandle`, `CursorPortionView`, `CursorQueryResponse` и `CursorMapResponse` — простые доменные модели без вспомогательной логики, всё форматирование происходит в самом плагине.

## Семантический указатель
`SemanticPointer` описывает стабильное положение в документе: ближайший заголовок (может быть `null`), нулевой индекс строки и нулевой символьный офсет с начала документа. `LinearPointer` дополнительно содержит линейный индекс элемента. Оба типа сериализуются в JSON через метод `Serialize` и используются в курсорных ответах. При разборе указателя `DescribePointer` принимает как `SemanticPointer`, так и `LinearPointer` в сериализованном виде.

## Пример использования
Поиск первого совпадения через `NavigationPlugin.QueryCursor` с дефолтным курсором:
```csharp
var handleJson = navigationPlugin.UseWholeBookCursor();
var portionJson = navigationPlugin.GetNextPortion(CursorContext.DefaultWholeBookForward);
var queryJson = await navigationPlugin.QueryCursor(CursorContext.DefaultWholeBookForward,
    "Locate the first mention of Ada Lovelace and return its semantic pointer.");
```

Благодаря курсору запрос идёт пакетами, не загружая целую книгу в память LLM.
