# Концепция курсоров

Курсор — именованный поток элементов `LinearDocument`, предназначенный для постраничного обхода длинного текста. Состояние курсора (позиция, параметры порции) живёт в `DocumentContext`, поэтому одна сессия может держать несколько независимых курсоров и переключаться между ними без дополнительных запросов к LLM.

## Параметры курсора
* **Имя** — строковый идентификатор, например `CUR_WHOLE_BOOK_FORWARD`, `CUR_WHOLE_BOOK_BACKWARD`, `CUR_PERSON_SEARCH`. Имя обязательно, ограничено 96 символами и уникально в рамках `DocumentContext`.
* **Лимиты порции** — максимум элементов и максимум размера в байтах. Лимиты задаются при создании курсора, значения должны находиться в диапазонах `1..200` для элементов и `1..65536` для байтов. Элементы группируются, пока не будет достигнут один из лимитов, но порция всегда содержит минимум один элемент.
* **Включение содержимого** (`includeContent`) — если `true`, `Markdown`/`Text` элемента возвращаются целиком; если `false`, текстовые поля зануляются, и курсор отдаёт только индексы/указатели.
* **Направление** — вперёд (`forward=true`) или назад (`forward=false`) по документу.

По умолчанию создаются курсоры полной книги `CUR_WHOLE_BOOK_FORWARD` и `CUR_WHOLE_BOOK_BACKWARD` с параметрами `20` элементов, `2048` байт, `includeContent=true`. Дополнительные сценарные курсоры (например, `CUR_PERSON_SEARCH`) создаются через `CursorAgentPlugin.CreateCursor` с нужными ограничениями.

## Структура порции
`CursorContext.GetNextPortion` возвращает `CursorPortion` с именем курсора, списком элементов и флагом `HasMore`. Размер порции ограничен лимитами, но если элемент больше лимита, он всё равно будет отдан один в отдельной порции. Для курсоров без содержимого `Markdown` и `Text` элементов будут пустыми.

Каждый элемент содержит стабильный `SemanticPointer`, тип (`Heading`, `Paragraph`, `ListItem`, `Image` и т.д.), уровень заголовка и индекс (`LinearItem.Index`). Эти значения используются в логике агента и в целевых наборах (`TargetSet`).

## CursorAgentPlugin
`CursorAgentPlugin` — единственный плагин, доступный агенту на текущем этапе. Он предоставляет LLM функции для создания курсоров, выборки батчей и запуска управляющего агента поверх курсора.

### Функции плагина
- **CreateCursor(cursorName, forward, maxElements, maxBytes, includeContent)** — создать или переинициализировать курсор. Валидирует имя (обязательное, ≤96 символов), диапазоны `maxElements` (`1..200`) и `maxBytes` (`1..65536`). Возвращает `CursorHandle` с фактическими параметрами.
- **CursorNext(cursorName)** — получить следующую `CursorPortionView`. Если курсор не создавался — ошибка `Cursor '<name>' is not defined`. Если курсор завершился и новых элементов нет — ошибка `Cursor '<name>' is complete, reset it before requesting more portions.`
- **TargetSetCreate(name?)** — создать целевой набор индексов. Возвращает `targetSetId` и логирует событие `target_set_create`.
- **TargetSetAdd(targetSetId, itemIndices)** — добавить индексы элементов (`LinearItem.Index`). Работает только в созданных наборах, возвращает `success` и `count`.
- **TargetSetGet(targetSetId)** — получить все сохранённые индексы набора: `itemIndices` упорядочены по возрастанию.
- **RunCursorAgent(cursorName, mode, taskDescription, targetSetId?, maxSteps?)** — запустить CursorAgent Runtime. Возвращает `CursorAgentResult` (`success`, `reason`, `firstItemIndex`, `summary`, `targetSetId`). Лимит шагов по умолчанию — `128`, верхняя граница — `512`. Для режима `CollectToTargetSet` `targetSetId` обязателен.

Все результаты сериализуются в JSON c `camelCase`, поэтому их легко парсить внутри tool-calling промпта.

### Режимы RunCursorAgent
* **FirstMatch** — агент ищет первое вхождение условия. Успех → `firstItemIndex` заполнен индексом `LinearItem.Index`, `summary` содержит краткое объяснение. Используется в сценариях «найди первое упоминание» или «остановись на первом совпадении».
* **CollectToTargetSet** — агент накапливает выбранные элементы в ранее созданном TargetSet через `target_set_add`. После завершения возвращает `targetSetId` и текстовое резюме, `firstItemIndex` не заполняется.
* **AggregateSummary** — агент читает весь курсор, суммирует детали и завершает `agent_finish_success` без индексов.

При неверном `mode` плагин возвращает ошибку с подсказкой по допустимым значениям (`FirstMatch`, `CollectToTargetSet`, `AggregateSummary`).

### Команды CursorAgent
Агент всегда общается через единый JSON-объект без кодовых блоков:

```json
{"action":"cursor_next","indices":[12],"firstItemIndex":42,"summary":"H2.p42 Ada Lovelace: biography"}
```

* **action** — одно из значений `cursor_next`, `target_set_add`, `agent_finish_success`, `agent_finish_not_found`.
* **indices** — массив индексов `LinearItem.Index`. Обязателен для `target_set_add`, опционален для остальных действий.
* **firstItemIndex** — индекс первого найденного элемента. Используется в `agent_finish_success` для режима `FirstMatch` и может отсутствовать в других режимах.
* **summary** — короткое текстовое пояснение (английский язык по умолчанию), включает `pointerLabel` и причину действия.

Логи отражают те же поля: `cursor_next` всплывает в логах как `cursor_batch`/`cursor_batch_complete`, завершение — `agent_finish_success` с итоговым JSON. Если агент возвращает несколько JSON подряд или посторонний текст, Runtime отправляет корректирующее сообщение `Return only one JSON action.`

### TargetSet сценарии
1. Агент вызывает `TargetSetCreate` и запоминает `targetSetId`.
2. Во время чтения курсора при необходимости вызывает `target_set_add` (action) с `indices` для каждой порции.
3. Хост-плагин может в любой момент позвать `TargetSetGet`, чтобы получить собранные индексы и, например, построить плейлист цитат.

## Правило «первого упоминания»
Чтобы результаты `FirstMatch` были предсказуемы, CursorAgent следует этим правилам:

1. **Что считается**: заголовки, абзацы, элементы списка, ячейки таблицы и подписи изображений. Блоки кода и цитаты учитываются только если запрос явно про них (агент сам решает по формулировке задания).
2. **Нормализация текста**: поиск нечувствителен к регистру, буква `ё` всегда приводится к `е`, повторяющиеся пробелы сворачиваются в один, пунктуация трактуется как границы слов. Искомая строка также нормализуется.
3. **Несколько упоминаний в одном элементе**: агент выбирает первый `LinearItem` с совпадением, а внутри элемента ориентируется на порядок появления (например, первое предложение).
4. **Заголовок против абзаца**: если запрос найден в заголовке, он считается более ранним, даже если следующий абзац содержит то же слово.
5. **Списки**: каждый элемент списка — отдельный кандидат. Если совпадение найдено в подпункте, его индекс используется как `firstItemIndex`.

Эти правила обязательно нужно проговаривать в prompt-шаблоне tool-calling агента, чтобы LLM не делал предположений.

## Семантический указатель
`SemanticPointer` описывает стабильное положение в документе: ближайший заголовок (может быть `null`), нулевой индекс строки и нулевой символьный офсет с начала документа. `LinearPointer` дополнительно содержит линейный индекс элемента. Оба типа сериализуются в JSON через `Pointer.Serialize()` и используются в `CursorPortionView`. `summary` должен включать `pointerLabel`, чтобы хост мог быстро сопоставить выбор агента с первоисточником.

## Пример последовательности для LLM
```text
1. Call CreateCursor("CUR_PERSON_SEARCH", true, 10, 4096, true)
2. Call CursorNext("CUR_PERSON_SEARCH") — получите items + hasMore
3. Повторяйте CursorNext, пока не найдёте первое совпадение
4. Верните {"action":"agent_finish_success","indices":[portion.items[0].index],"firstItemIndex":portion.items[0].index,"summary":"H2.p42 Ada Lovelace: biography"}
```

## Историческая справка
Ранние версии документации ссылались на `NavigationPlugin`, `UseWholeBookCursor`, `QueryCursor`, `MapCursor`, `DescribePointer` и статусы `found|continue|complete`. Эти функции больше не доступны агенту: вместо них используется `CursorAgentPlugin` и перечисленные выше команды. Сохраняйте новую терминологию при обновлении prompt-шаблонов.
