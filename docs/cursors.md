# Концепция курсоров

## AITextEditor: редактирование большой книги с LLM через курсор и доменные операции

Этот проект про редактирование большого Markdown-документа (например, книги) по текстовым командам пользователя.

Ключевая идея: LLM не держит всю книгу в контексте и не переписывает сырой текст. Вместо этого LLM:
- читает документ порциями через курсор;
- находит нужное место;
- вызывает доменные операции редактирования над моделью документа;
- получает в ответ семантический указатель и Markdown-фрагмент.

### Почему не кладем всю книгу в контекст
Книга может быть большой, и "весь текст в контекст" быстро упирается в:
- стоимость и задержки;
- шум и падение точности на длинных входах;
- риск непредсказуемых побочных правок (модель переписывает лишнее).

Поэтому доступ к тексту идёт порциями, а не «все сразу».

### Почему редактируем доменную модель, а не лепим патчи поверх текста
Мы не хотим, чтобы модель работала с «сырой строкой файла» и пыталась аккуратно сохранить Markdown руками.

Мы редактируем доменную модель документа, потому что:
- операции изменения становятся детерминированными и проверяемыми;
- структура Markdown сохраняется автоматически логикой модели;
- итоговый Markdown получается из модели при сохранении.

Патчи (diff, JSON patch) полезны в других архитектурах, но в нашем дизайне мы делаем прямые операции над моделью и сохраняем результат.

### Основные понятия

#### Семантический указатель
Один, единый способ адресовать место в документе. Он используется везде: чтение, навигация, редактирование, ответы. Мы сознательно не вводим дополнительные handle-и, transactionId и прочие идентификаторы — это вне текущего скоупа.

#### Курсор
Курсор — «итератор» по документу, который возвращает элементы порциями. Порция ограничена по размеру (например, число элементов и bytes), чтобы не раздувать контекст.

Курсор возвращает:
- список элементов (в виде Markdown или упрощённого текста);
- семантические указатели для элементов.

#### Cursor Agent
Отдельный агент, который умеет «ходить» по курсору и выполнять одну конкретную навигационную задачу: найти первое упоминание, найти абзац по описанию, собрать несколько кандидатов.

### Роль подагента в системе
Система разделена на две роли.

1. **Основной агент (Command Agent)**
   - принимает команду пользователя;
   - выбирает стратегию;
   - решает, какой подагент нужен;
   - применяет доменные операции редактирования.
2. **Подагент (Cursor Agent)**
   - выполняет цикл «запрос порции → анализ → следующий шаг»;
   - возвращает результат в минимальном виде.

Это нужно, чтобы изолировать длинные циклы листания от основной логики, упростить правила, ограничить поведение подагента и сделать логи понятнее.

### Как проходит обработка команды
Типовой ход (без деталей классов):

1. Пользователь пишет команду. Пример: «Найди первое упоминание профессора Звёздочкина (исключая заголовки)».
2. Основной агент формулирует задачу для подагента, коротко и с ограничениями («исключая заголовки»).
3. Подагент листает курсор порциями, пока не найдёт совпадение, и возвращает `semanticPointer`, `markdown`, опционально `confidence` и `reasons`.
4. Основной агент использует результат — отвечает пользователю, если это поиск, либо применяет правку в этой точке.

### Инструменты, которые нужны для такого подхода

#### Навигация
- `CreateCursor(options)`: создать курсор с лимитами и фильтрами;
- `CursorNext(cursor)`: получить следующую порцию элементов;
- `Read(pointer)`: получить элемент по семантическому указателю.

Фильтры курсора (например, «исключая заголовки») лучше поддерживать на стороне курсора, чтобы не тратить токены на игнорирование.

#### Редактирование
Сейчас делаем только операции, которые не меняют иерархию документа:
- `ReplaceText(pointer, newMarkdown)` — заменить содержимое элемента;
- `InsertAfter(pointer, markdown)` — вставить новый элемент после;
- `InsertBefore(pointer, markdown)` — вставить новый элемент до;
- `Delete(pointer)` — удалить элемент.

Что пока не делаем: операции со структурой (повысить заголовок, пересобрать главы, перемещать секции). Это ограничение, чтобы стабилизировать базовый сценарий «найти место и поменять текст».

#### Формат результата инструмента
Минимальный контракт ответа инструмента:
- `semanticPointer`;
- `markdown`;
- опционально `confidence`, `reasons`.

Мы не возвращаем summary как единственный носитель смысла; summary — вспомогательное поле для логов.

### Поиск вместо линейного листания
Линейное листание курсором работает всегда, но может быть медленным. Планируем слой ускорения (пока не делаем): exact search, semantic search (embeddings), hybrid search. Любой поиск обязан возвращать семантические указатели, а текст подтягивается отдельно через `Read(pointer)` или курсор вокруг места.

### Что вне скоупа сейчас
Мы осознанно не делаем:
- `PreviewChange`, `ApplyTransaction`, `Undo/Redo`;
- отдельную верификацию валидности Markdown;
- версионирование, откат, транзакционные `id`.

Это допустимо, потому что мы редактируем доменную модель, а операции гарантируют целостность и сохраняют Markdown из модели.

### Писательские вспомогательные данные
Справочники персонажей, локаций, таймлайн, глоссарий и стиль-гайд помогают LLM не ломать канон. Пока не реализовано, но планируется как отдельный слой с tool-ами для чтения/обновления карточек и подключения их к поиску и генерации.

### Принципы дизайна
- Читать порциями, а не целиком;
- Адресовать всё одним семантическим указателем;
- Изменять через доменные операции, а не свободное переписывание текста;
- Длинные циклы навигации выносить в подагента;
- В ответах инструментов возвращать минимум: pointer + markdown + опционально confidence/reasons.

## Stateful Cursor Agent Loop

Этот раздел описывает, как сабагент с курсором работает с «памятью» при обработке больших документов, когда каждый вызов LLM изолирован и не помнит предыдущие шаги.

Ключевая идея: память живёт не в LLM, а в рантайме. Каждый шаг цикла передаёт в LLM компактный **Snapshot** состояния и получает обратно **Decision + StateUpdate**. Рантайм применяет обновление и продолжает цикл.

### Зачем это нужно

Задачи вида «найди второй диалог персонажа X» или «найди следующую орфографическую ошибку после этого места» не решаются локально на одном абзаце без памяти. Без состояния LLM будет снова и снова возвращать первый найденный матч.

---

## Понятия

### Session Store

Хранилище артефактов сессии, доступное всем сабагентам в рамках обработки одного пользовательского запроса.

- хранит **TaskState** между итерациями `while`;
- хранит результаты (evidence) для передачи другим сабагентам;
- может быть большим, но в LLM передаётся только сжатый Snapshot.

### TaskState

Полное состояние конкретной задачи сабагента. Оно обновляется на каждом шаге цикла.

Минимальный состав:

- **Goal**: что ищем и критерии;
- **Found**: найденные доказательства (evidence);
- **Seen**: что уже обработали, чтобы не находить одно и то же повторно;
- **Progress**: маркер продвижения по потоку кандидатов;
- **Budgets**: лимиты на размер памяти, число кандидатов и т.п. (служебное).

### Snapshot

Сжатое представление TaskState, которое реально передаётся в LLM на каждом шаге.

---

## Контракт данных

### EvidenceItem

Минимальная единица результата, которую можно хранить и передавать между сабагентами.

```json
{
   "pointer": "1.2.3.p45",
   "excerpt": "— Звездочкин, вы опять опоздали! — ...",
   "reason": "Диалоговая форма + явная привязка к персонажу",
   "score": 0.91
}
```

### TaskState (пример)

```json
{
   "goal": {
      "type": "FindNthDialogue",
      "character": "Профессор Звездочкин",
      "n": 2
   },
   "found": [
      { "pointer": "1.2.1.p10", "excerpt": "— ...", "score": 0.88 }
   ],
   "seenPointers": ["1.2.1.p10", "1.2.1.p11"],
   "progress": {
      "continueAfterPointer": "1.2.1.p11"
   },
   "limits": {
      "maxFound": 20,
      "maxSeenTail": 200
   }
}
```

### Snapshot (пример)

Snapshot должен быть маленьким. Обычно достаточно:

- цель;
- top-K найденных;
- хвост `seenPointers` (последние N);
- маркер прогресса;
- правило дедупликации.

```json
{
   "goal": { "type": "FindNthDialogue", "character": "Профессор Звездочкин", "n": 2 },
   "alreadyFound": [
      { "pointer": "1.2.1.p10", "excerpt": "— ...", "score": 0.88 }
   ],
   "seenTail": ["1.2.1.p10", "1.2.1.p11"],
   "progress": { "continueAfterPointer": "1.2.1.p11" },
   "dedupRule": "Never return a pointer already present in alreadyFound or seenTail"
}
```

### Batch (порция кандидатов)

Источник кандидатов может быть любым: курсор, exact search, semantic search, гибрид. Важно лишь, что он отдаёт поток элементов с `pointer`.

```json
{
   "batchId": "cursor:main:chunk-0042",
   "items": [
      { "pointer": "1.2.2.p14", "markdown": "— ... — сказал Звездочкин." },
      { "pointer": "1.2.2.p15", "markdown": "Они вышли на улицу..." }
   ]
}
```

### Decision (ответ LLM)

LLM возвращает:

- решение: продолжать или завершать;
- новые evidence (если найдены);
- патч состояния (`StateUpdate`);
- опционально запрос допконтекста.

```json
{
   "decision": "continue",
   "newEvidence": [
      {
         "pointer": "1.2.2.p14",
         "excerpt": "— ... — сказал Звездочкин.",
         "reason": "Диалог + указание говорящего",
         "score": 0.93
      }
   ],
   "stateUpdate": {
      "addSeenPointers": ["1.2.2.p14", "1.2.2.p15"],
      "setContinueAfterPointer": "1.2.2.p15"
   },
   "needMoreContext": false
}
```

Когда найдено достаточно (например, найден N-й диалог), LLM отвечает:

```json
{
   "decision": "done",
   "result": {
      "pointer": "1.2.2.p14",
      "excerpt": "— ... — сказал Звездочкин.",
      "score": 0.93
   },
   "stateUpdate": {
      "addSeenPointers": ["1.2.2.p14", "1.2.2.p15"]
   }
}
```

---

## Цикл сабагента

Сабагент выполняет цикл `while`, но память переносится через `TaskState`.

### Псевдокод

```text
load state from SessionStore

while true:
   batch = CandidateSource.next(state.progress)
   if batch is end:
      return not found

   snapshot = buildSnapshot(state)
   prompt = buildPrompt(systemRules, goal, snapshot, batch)

   decision = callLLM(prompt)  // JSON only

   applyStateUpdate(state, decision.stateUpdate)
   addNewEvidence(state, decision.newEvidence)
   persist state to SessionStore

   if stopConditionMet(state):   // например state.found.count >= goal.n
      return state.found[goal.n - 1]

   if decision.needMoreContext:
      enqueue extra context via Read(pointer) or neighbor batches
```

---

## Правила обновления памяти

### Дедупликация

Нельзя возвращать один и тот же результат повторно.

- базовый ключ: `pointer`;
- при необходимости: `pointer + localOffset` или `hash(excerpt)`.

### Сжатие памяти

Чтобы Snapshot не раздувал контекст:

- `found`: хранить полный список в Session Store, но в Snapshot отдавать только top-K;
- `seenPointers`: хранить полное множество, но в Snapshot отдавать хвост (последние N) + правило «не возвращай seen».

### Маркер прогресса

Используется не «номер итерации», а указатель на место в потоке:

- `continueAfterPointer`;
- `lastBatchTailPointer`.

---

## Передача результатов другим сабагентам

Результаты и состояние сабагента сохраняются в Session Store как артефакты.

Пример:

- Cursor Agent пишет:
   - `session.task.findDialogue.state`
   - `session.task.findDialogue.found`
- Другой агент (например, Context Builder) читает `found`, подтягивает окружение через `Read(pointer)` и формирует финальный ответ или данные для редактирования.

---

## Рекомендации по промпту для сабагента

- Требовать ответ строго в JSON по схеме Decision;
- Явно перечислять `alreadyFound` и `dedupRule`;
- Просить возвращать `needMoreContext` вместо попыток угадать по неполному контексту;
- Считать задачу завершённой только при выполнении stop-condition по состоянию, а не по «ощущению модели».

Курсор — именованный поток элементов `LinearDocument`, предназначенный для постраничного обхода длинного текста. Состояние курсора (позиция, параметры порции) живёт в `DocumentContext`, поэтому одна сессия может держать несколько независимых курсоров и переключаться между ними без дополнительных запросов к LLM.

## Параметры курсора
* **Имя** — строковый идентификатор, например `CUR_WHOLE_BOOK_FORWARD`, `CUR_WHOLE_BOOK_BACKWARD`, `CUR_PERSON_SEARCH`. Имя обязательно, ограничено 96 символами и уникально в рамках `DocumentContext`.
* **Лимиты порции** — максимум элементов и максимум размера в байтах. Лимиты задаются при создании курсора, значения должны находиться в диапазонах `1..200` для элементов и `1..65536` для байтов. Элементы группируются, пока не будет достигнут один из лимитов, но порция всегда содержит минимум один элемент.
* **Включение содержимого** (`includeContent`) — если `true`, `Markdown`/`Text` элемента возвращаются целиком; если `false`, текстовые поля зануляются, и курсор отдаёт только индексы/указатели.
* **Направление** — вперёд (`forward=true`) или назад (`forward=false`) по документу.

По умолчанию создаются курсоры полной книги `CUR_WHOLE_BOOK_FORWARD` и `CUR_WHOLE_BOOK_BACKWARD` с параметрами `20` элементов, `2048` байт, `includeContent=true`. Дополнительные сценарные курсоры (например, `CUR_PERSON_SEARCH`) создаются через `CursorAgentPlugin.CreateCursor` с нужными ограничениями.

## Структура порции
`CursorContext.GetNextPortion` возвращает `CursorPortion` с именем курсора, списком элементов и флагом `HasMore`. Размер порции ограничен лимитами, но если элемент больше лимита, он всё равно будет отдан один в отдельной порции. Для курсоров без содержимого `Markdown` и `Text` элементов будут пустыми.

Каждый элемент содержит стабильный `SemanticPointer`, тип (`Heading`, `Paragraph`, `ListItem`, `Image` и т.д.), уровень заголовка и индекс (`LinearItem.Index`). Эти значения используются в логике агента и в целевых наборах (`TargetSet`).

## CursorAgentPlugin
`CursorAgentPlugin` — единственный плагин, доступный агенту на текущем этапе. Он предоставляет LLM функции для создания курсоров, выборки батчей и запуска управляющего агента поверх курсора.

### Функции плагина
- **CreateCursor(cursorName, forward, maxElements, maxBytes, includeContent)** — создать или переинициализировать курсор. Валидирует имя (обязательное, ≤96 символов), диапазоны `maxElements` (`1..200`) и `maxBytes` (`1..65536`). Возвращает `CursorHandle` с фактическими параметрами.
- **CursorNext(cursorName)** — получить следующую `CursorPortionView`. Если курсор не создавался — ошибка `Cursor '<name>' is not defined`. Если курсор завершился и новых элементов нет — ошибка `Cursor '<name>' is complete, reset it before requesting more portions.`
- **TargetSetCreate(name?)** — создать целевой набор индексов. Возвращает `targetSetId` и логирует событие `target_set_create`.
- **TargetSetAdd(targetSetId, itemIndices)** — добавить индексы элементов (`LinearItem.Index`). Работает только в созданных наборах, возвращает `success` и `count`.
- **TargetSetGet(targetSetId)** — получить все сохранённые индексы набора: `itemIndices` упорядочены по возрастанию.
- **RunCursorAgent(cursorName, mode, taskDescription, targetSetId?, maxSteps?, taskId?, state?)** — запустить CursorAgent Runtime. При повторном вызове с тем же `taskId` и сохранённым `state` агент продолжает шаги с того же места, не тратя токены на пересказ истории. Возвращает `CursorAgentResult` (`success`, `reason`, `firstItemIndex`, `summary`, `targetSetId`, `semanticPointer`, `markdown`, опционально `confidence`, `reasons`). Лимит шагов по умолчанию — `128`, верхняя граница — `512`. Для режима `CollectToTargetSet` `targetSetId` обязателен.

Все результаты сериализуются в JSON c `camelCase`, поэтому их легко парсить внутри tool-calling промпта.

### Режимы RunCursorAgent
* **FirstMatch** — агент ищет первое вхождение условия. Успех → `firstItemIndex` заполнен индексом `LinearItem.Index`, `summary` содержит краткое объяснение. Используется в сценариях «найди первое упоминание» или «остановись на первом совпадении».
* **CollectToTargetSet** — агент накапливает выбранные элементы в ранее созданном TargetSet через `target_set_add`. После завершения возвращает `targetSetId` и текстовое резюме, `firstItemIndex` не заполняется.
* **AggregateSummary** — агент читает весь курсор, суммирует детали и завершает `agent_finish_success` без индексов.

При неверном `mode` плагин возвращает ошибку с подсказкой по допустимым значениям (`FirstMatch`, `CollectToTargetSet`, `AggregateSummary`).

### Команды CursorAgent
Агент всегда общается через единый JSON-объект без кодовых блоков:

```json
{"action":"cursor_next","indices":[12],"firstItemIndex":42,"summary":"H2.p42 Ada Lovelace: biography"}
```

* **action** — одно из значений `cursor_next`, `target_set_add`, `agent_finish_success`, `agent_finish_not_found`.
* **indices** — массив индексов `LinearItem.Index`. Обязателен для `target_set_add`, опционален для остальных действий.
* **firstItemIndex** — индекс первого найденного элемента. Используется в `agent_finish_success` для режима `FirstMatch` и может отсутствовать в других режимах.
* **summary** — короткое текстовое пояснение (английский язык по умолчанию), включает `pointerLabel` и причину действия.

Логи отражают те же поля: `cursor_next` всплывает в логах как `cursor_batch`/`cursor_batch_complete`, завершение — `agent_finish_success` с итоговым JSON. Если агент возвращает несколько JSON подряд или посторонний текст, Runtime отправляет корректирующее сообщение `Return only one JSON action.`

### TargetSet сценарии
1. Агент вызывает `TargetSetCreate` и запоминает `targetSetId`.
2. Во время чтения курсора при необходимости вызывает `target_set_add` (action) с `indices` для каждой порции.
3. Хост-плагин может в любой момент позвать `TargetSetGet`, чтобы получить собранные индексы и, например, построить плейлист цитат.

## Правило «первого упоминания»
Чтобы результаты `FirstMatch` были предсказуемы, CursorAgent следует этим правилам:

1. **Что считается**: заголовки, абзацы, элементы списка, ячейки таблицы и подписи изображений. Блоки кода и цитаты учитываются только если запрос явно про них (агент сам решает по формулировке задания).
2. **Нормализация текста**: поиск нечувствителен к регистру, буква `ё` всегда приводится к `е`, повторяющиеся пробелы сворачиваются в один, пунктуация трактуется как границы слов. Искомая строка также нормализуется.
3. **Несколько упоминаний в одном элементе**: агент выбирает первый `LinearItem` с совпадением, а внутри элемента ориентируется на порядок появления (например, первое предложение).
4. **Заголовок против абзаца**: если запрос найден в заголовке, он считается более ранним, даже если следующий абзац содержит то же слово.
5. **Списки**: каждый элемент списка — отдельный кандидат. Если совпадение найдено в подпункте, его индекс используется как `firstItemIndex`.

Эти правила обязательно нужно проговаривать в prompt-шаблоне tool-calling агента, чтобы LLM не делал предположений.

## Семантический указатель
`SemanticPointer` описывает стабильное положение в документе: ближайший заголовок (может быть `null`), нулевой индекс строки и нулевой символьный офсет с начала документа. `LinearPointer` дополнительно содержит линейный индекс элемента. Оба типа сериализуются в JSON через `Pointer.Serialize()` и используются в `CursorPortionView`. `summary` должен включать `pointerLabel`, чтобы хост мог быстро сопоставить выбор агента с первоисточником.

## Пример последовательности для LLM
```text
1. Call CreateCursor("CUR_PERSON_SEARCH", true, 10, 4096, true)
2. Call CursorNext("CUR_PERSON_SEARCH") — получите items + hasMore
3. Повторяйте CursorNext, пока не найдёте первое совпадение
4. Верните {"action":"agent_finish_success","indices":[portion.items[0].index],"firstItemIndex":portion.items[0].index,"summary":"H2.p42 Ada Lovelace: biography"}
```

## Историческая справка
Ранние версии документации ссылались на `NavigationPlugin`, `UseWholeBookCursor`, `QueryCursor`, `MapCursor`, `DescribePointer` и статусы `found|continue|complete`. Эти функции больше не доступны агенту: вместо них используется `CursorAgentPlugin` и перечисленные выше команды. Сохраняйте новую терминологию при обновлении prompt-шаблонов.
