# Потоковый навигационный агент

## Зачем нужен потоковый режим
AITextEditor редактирует большие Markdown-документы по текстовым командам. Модель не держит весь текст в контексте: она читает документ небольшими порциями, находит нужное место и применяет доменные операции над моделью документа. Это удешевляет работу с длинными книгами, уменьшает шум и исключает случайные правки «лишнего» текста.

Основные принципы:
- читать документ порциями, а не целиком;
- адресовать всё одним семантическим указателем;
- изменять через доменные операции, а не свободным переписыванием Markdown;
- длинные циклы навигации выносить в отдельного подагента;
- в ответах инструментов возвращать минимум: pointer + markdown + при необходимости confidence/reasons.

## Идеология подсказок и памяти
Подагенту нужен устойчивый контекст между итерациями, чтобы он мог сопоставлять найденные фрагменты и избегать повторов. При
обновлении промптов придерживаемся следующих принципов:
- **Показываем последние находки.** В snapshot-сообщениях достаточно компактного списка последних `pointer` + короткого `excerpt`
  и причины выбора, ограниченных `SnapshotEvidenceLimit`. Это позволяет модели помнить недавние совпадения без раздувания токенов.
- **Разделяем инструкции и данные.** Историю шага и счётчики удобнее выдавать через отдельное tool-сообщение (`cursor_state`),
  оставляя системный промпт минимальным и стабильным. При необходимости тяжёлые поля (excerpts) можно отключать, не переписывая
  промпт.
- **Даем модели право запросить память.** Поле `needMoreContext` уже парсится рантаймом; при значении `true` можно отвечать
  дополнительным tool-вызовом с расширенной историей (список evidence, последние seen-пойнтеры), чтобы сложные поиски получали
  больше данных только по запросу.
- **Фиксируем стратегию задачи.** В задания добавляем `mode/strategy` (`first_match`, `collect_many`, `aggregate_summary`,
  `backward_scan`), чтобы подагент выбирал корректное правило останова и ожидания по evidence под конкретный пользовательский
  запрос.
- **Структурируем критерии извлечения.** В `taskDefinitionPrompt` описываем признаки искомого паттерна (например, что считать
  диалогом или «запутанной» главой) и порядок сравнения батчей. Подагенту важны не только шаги навигации, но и единые критерии
  матчинга.
- **Позволяем управлять шагами.** Через `TaskState.Update` и `maxSteps` можно подстраивать обход под сценарий: продолжить после
  заданного pointer, увеличить `maxFound`, разрешить несколько проходов для сбора подборки. Это делает поведение воспроизводимым
  и прозрачным для основного агента.

## Роли и общий сценарий
1. **Основной агент (Command Agent)** получает команду пользователя, выбирает стратегию, формирует задание для подагента и применяет операции редактирования над моделью документа.
2. **Подагент потоковой навигации (Streaming Agent, в коде `CursorAgent`)** идёт по документу порциями, пока не выполнит задачу: найти первое упоминание, собрать подборку кандидатов или сделать сводку. Он возвращает компактный JSON-ответ с указателем и кратким объяснением. Новый подагент полностью управляется LLM через функции (создание курсора, чтение порций, финальный JSON).

Типовой ход работы:
1. Пользователь пишет команду — например: «Найди первое упоминание профессора Звёздочкина (исключая заголовки)».
2. Основной агент формулирует задачу для подагента.
3. Подагент запускается одной функцией `RunCursorAgent(...)`: внутри неё создаётся локальный курсор с нужными лимитами, подагент запрашивает порции, анализирует их и завершается JSON-действием.
4. Основной агент использует результат — отвечает пользователю или применяет правку в указанной точке.

## Инструменты
### Навигация
- **Типы курсоров.** Сейчас есть два вида курсоров: (1) полноценный LLM-курсор, который управляется моделью через функции (`chat_cursor_tools-read_cursor_batch` внутри `chat_cursor_agent-run_chat_cursor_agent`), и (2) быстрый keyword-курсор, который фильтрует элементы по ключевым словам без участия LLM и отдаёт только совпадения.
- `RunCursorAgent(options)`: создаёт локальный курсор с лимитами по размеру порции и направлению, запускает подагента и возвращает результат.
- `Read(pointer)`: получает элемент по семантическому указателю.

Фильтры («исключая заголовки» и подобные) лучше держать в логике курсора или задания, чтобы не тратить токены на ручное игнорирование контента в промпте.

### Редактирование
Операции не меняют иерархию документа и сохраняют Markdown из модели автоматически:
- `ReplaceText(pointer, newMarkdown)` — заменить содержимое элемента;
- `InsertAfter(pointer, markdown)` — вставить новый элемент после;
- `InsertBefore(pointer, markdown)` — вставить новый элемент до;
- `Delete(pointer)` — удалить элемент.

## Локальный курсор внутри `RunCursorAgent`
Курсор больше не именуется и не хранится в рантайме: он существует только внутри вызова `RunCursorAgent`. При каждом запуске подагент стартует с нуля и сам запрашивает порции.

Параметры порций:
- **Лимиты** — максимум элементов (1..200) и максимум байт (1..65536) в одной порции. Порция всегда содержит хотя бы один элемент; слишком крупный элемент отдаётся отдельной порцией.
- **Содержимое** — `includeContent=true` возвращает `Markdown`/`Text` целиком; при `false` текстовые поля пустые, остаются только указатели и метаданные.
- **Направление** — вперёд (`forward=true`) или назад (`forward=false`).

`RunCursorAgent` возвращает `CursorPortionView` со списком элементов и флагом `HasMore`, пока подагент не завершит работу.

## Сворачивание истории сообщений
Чат-агент подрезает историю перед каждым запросом к модели (`FunctionCallAwareChatHistoryCompressor`). Если сообщений становится больше `MaxChatMessages`, удаляются самые ранние несистемные; для цепочек функции выбрасываются вызов и его ближайший ответ целиком. Сворачивание может происходить посередине длинной серии tool-вызовов, чтобы не раздувать контекст.

## Плагины и команды
`CursorAgentPlugin` (в промптах можно называть «Streaming Agent plugin») — основной набор функций, доступный LLM сейчас:

- **RunCursorAgent(forward, maxElements, maxBytes, includeContent, mode, taskDescription, targetSetId?, maxSteps?, taskId?, state?)** — запускает потоковый обход и возвращает `CursorAgentResult` (`success`, `reason`, `summary`, `targetSetId`, `semanticPointer`, `markdown`, опционально `confidence`, `reasons`). Лимит шагов по умолчанию — `128`, верхняя граница — `512`. Для режима `CollectToTargetSet` `targetSetId` обязателен.
- **TargetSetCreate(name?)** — создаёт целевой набор указателей. Возвращает `targetSetId` и событие лога `target_set_create`.
- **TargetSetAdd(targetSetId, pointers)** — добавляет семантические указатели в набор, возвращает `success` и `count`.
- **TargetSetGet(targetSetId)** — возвращает упорядоченный список `pointers` выбранного набора.

Режимы `RunCursorAgent`:
- **FirstMatch** — остановиться на первом совпадении. Успех даёт `semanticPointer` и короткое объяснение.
- **CollectToTargetSet** — накапливать найденные элементы в `TargetSet`, затем вернуть его идентификатор и summary.
- **AggregateSummary** — пройти курсор целиком, собрать сводку и завершить без указателей.

Команды подагента — всегда один JSON-объект (без кодовых блоков):
```json
{
  "action": "continue|stop",
  "batchFound": true|false,
  "newEvidence": [
    { "pointer": "...", "excerpt": "...", "reason": "..." }
  ]
}
```
- `action` — `continue` (продолжить сканирование) или `stop` (остановиться, если найдено достаточно или достигнут лимит);
- `batchFound` — `true`, если в текущей порции найдено что-то полезное, иначе `false`;
- `newEvidence` — список найденных фрагментов.

Логи отражают те же действия (`cursor_batch`, `cursor_batch_complete`, `agent_stopped`). Если модель выдаёт несколько JSON подряд или посторонний текст, рантайм отвечает подсказкой «Return only one JSON action.»

## Правила «первого упоминания»
Чтобы результаты `FirstMatch` были предсказуемыми:
1. Считаем заголовки, абзацы, элементы списка, ячейки таблицы и подписи изображений; код и цитаты — только если запрос про них.
2. Нормализуем текст: регистр не важен, `ё` → `е`, лишние пробелы схлопываются, пунктуация задаёт границы слов.
3. Если в элементе несколько совпадений, берём первое; в списках каждый пункт отдельный.
4. Заголовок победит абзац с тем же совпадением, если он встречается раньше.
5. В summary обязательно указывать `pointerLabel`, чтобы хост мог сопоставить выбор.

## Семантический указатель
`SemanticPointer` фиксирует положение в документе: ближайший заголовок (может быть `null`), индекс строки и символьный офсет. `LinearPointer` добавляет линейный индекс элемента. Они сериализуются через `Pointer.Serialize()` и используются в `CursorPortionView` и ответах плагина.

Для указания на место и части книги мы используем семантический указатель. Нам не нужно оптимизировать, кешировать или мапить его на индексы — мы используем его целиком как есть.

## Минимальный пример промпта
```
1. Call RunCursorAgent(true, 10, 4096, true, "FirstMatch", "Найди первое упоминание персонажа"...)
2. Агент сам запрашивает порции и останавливается на первом совпадении.
3. Возвращает JSON с action=agent_finish_success, semanticPointer и summary с pointerLabel.
```
