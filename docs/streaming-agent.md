# Потоковый навигационный агент

## Зачем нужен потоковый режим
AITextEditor редактирует большие Markdown-документы по текстовым командам. Модель не держит весь текст в контексте: она читает документ небольшими порциями, находит нужное место и применяет доменные операции над моделью документа. Это удешевляет работу с длинными книгами, уменьшает шум и исключает случайные правки «лишнего» текста.

Основные принципы:
- читать документ порциями, а не целиком;
- адресовать всё одним семантическим указателем;
- изменять через доменные операции, а не свободным переписыванием Markdown;
- длинные циклы навигации выносить в отдельного подагента;
- в ответах инструментов возвращать минимум: pointer + markdown + при необходимости confidence/reasons.

## Роли и общий сценарий
1. **Основной агент (Command Agent)** получает команду пользователя, выбирает стратегию, формирует задание для подагента и применяет операции редактирования над моделью документа.
2. **Подагент потоковой навигации (Streaming Agent, в коде `CursorAgent`)** идёт по документу порциями, пока не выполнит задачу: найти первое упоминание, собрать подборку кандидатов или сделать сводку. Он возвращает компактный JSON-ответ с указателем и кратким объяснением.

Типовой ход работы:
1. Пользователь пишет команду — например: «Найди первое упоминание профессора Звёздочкина (исключая заголовки)».
2. Основной агент формулирует задачу для подагента.
3. Подагент запускается одной функцией `RunCursorAgent(...)`: внутри неё создаётся локальный курсор с нужными лимитами, подагент запрашивает порции, анализирует их и завершается JSON-действием.
4. Основной агент использует результат — отвечает пользователю или применяет правку в указанной точке.

## Инструменты
### Навигация
- `RunCursorAgent(options)`: создаёт локальный курсор с лимитами по размеру порции и направлению, запускает подагента и возвращает результат.
- `Read(pointer)`: получает элемент по семантическому указателю.

Фильтры («исключая заголовки» и подобные) лучше держать в логике курсора или задания, чтобы не тратить токены на ручное игнорирование контента в промпте.

### Редактирование
Операции не меняют иерархию документа и сохраняют Markdown из модели автоматически:
- `ReplaceText(pointer, newMarkdown)` — заменить содержимое элемента;
- `InsertAfter(pointer, markdown)` — вставить новый элемент после;
- `InsertBefore(pointer, markdown)` — вставить новый элемент до;
- `Delete(pointer)` — удалить элемент.

## Локальный курсор внутри `RunCursorAgent`
Курсор больше не именуется и не хранится в рантайме: он существует только внутри вызова `RunCursorAgent`. При каждом запуске подагент стартует с нуля и сам запрашивает порции.

Параметры порций:
- **Лимиты** — максимум элементов (1..200) и максимум байт (1..65536) в одной порции. Порция всегда содержит хотя бы один элемент; слишком крупный элемент отдаётся отдельной порцией.
- **Содержимое** — `includeContent=true` возвращает `Markdown`/`Text` целиком; при `false` текстовые поля пустые, остаются только указатели и метаданные.
- **Направление** — вперёд (`forward=true`) или назад (`forward=false`).

`RunCursorAgent` возвращает `CursorPortionView` со списком элементов и флагом `HasMore`, пока подагент не завершит работу.

## Плагины и команды
`CursorAgentPlugin` (в промптах можно называть «Streaming Agent plugin») — основной набор функций, доступный LLM сейчас:

- **RunCursorAgent(forward, maxElements, maxBytes, includeContent, mode, taskDescription, targetSetId?, maxSteps?, taskId?, state?)** — запускает потоковый обход и возвращает `CursorAgentResult` (`success`, `reason`, `summary`, `targetSetId`, `semanticPointer`, `markdown`, опционально `confidence`, `reasons`). Лимит шагов по умолчанию — `128`, верхняя граница — `512`. Для режима `CollectToTargetSet` `targetSetId` обязателен.
- **TargetSetCreate(name?)** — создаёт целевой набор указателей. Возвращает `targetSetId` и событие лога `target_set_create`.
- **TargetSetAdd(targetSetId, pointers)** — добавляет семантические указатели в набор, возвращает `success` и `count`.
- **TargetSetGet(targetSetId)** — возвращает упорядоченный список `pointers` выбранного набора.

Режимы `RunCursorAgent`:
- **FirstMatch** — остановиться на первом совпадении. Успех даёт `semanticPointer` и короткое объяснение.
- **CollectToTargetSet** — накапливать найденные элементы в `TargetSet`, затем вернуть его идентификатор и summary.
- **AggregateSummary** — пройти курсор целиком, собрать сводку и завершить без указателей.

Команды подагента — всегда один JSON-объект (без кодовых блоков):
```json
{"action":"cursor_next","pointers":["..."],"summary":"H2.p42 Ada Lovelace: biography"}
```
- `action` — `cursor_next`, `target_set_add`, `agent_finish_success`, `agent_finish_not_found`;
- `pointers` — список семантических указателей, обязателен для `target_set_add`;
- `summary` — краткое пояснение (по умолчанию на английском), включая `pointerLabel`.

Логи отражают те же действия (`cursor_batch`, `cursor_batch_complete`, `agent_finish_success`). Если модель выдаёт несколько JSON подряд или посторонний текст, рантайм отвечает подсказкой «Return only one JSON action.»

## Правила «первого упоминания»
Чтобы результаты `FirstMatch` были предсказуемыми:
1. Считаем заголовки, абзацы, элементы списка, ячейки таблицы и подписи изображений; код и цитаты — только если запрос про них.
2. Нормализуем текст: регистр не важен, `ё` → `е`, лишние пробелы схлопываются, пунктуация задаёт границы слов.
3. Если в элементе несколько совпадений, берём первое; в списках каждый пункт отдельный.
4. Заголовок победит абзац с тем же совпадением, если он встречается раньше.
5. В summary обязательно указывать `pointerLabel`, чтобы хост мог сопоставить выбор.

## Семантический указатель
`SemanticPointer` фиксирует положение в документе: ближайший заголовок (может быть `null`), индекс строки и символьный офсет. `LinearPointer` добавляет линейный индекс элемента. Они сериализуются через `Pointer.Serialize()` и используются в `CursorPortionView` и ответах плагина.

Для указания на место и части книги мы используем семантический указатель. Нам не нужно оптимизировать, кешировать или мапить его на индексы — мы используем его целиком как есть.

## Минимальный пример промпта
```
1. Call RunCursorAgent(true, 10, 4096, true, "FirstMatch", "Найди первое упоминание персонажа"...)
2. Агент сам запрашивает порции и останавливается на первом совпадении.
3. Возвращает JSON с action=agent_finish_success, semanticPointer и summary с pointerLabel.
```

## Историческая справка
Ранее курсоры были именованными и жили в общей инфраструктуре (`UseWholeBookCursor`, `QueryCursor`, `MapCursor`, `DescribePointer`, статусы `found|continue|complete`). Теперь курсор создаётся локально внутри `RunCursorAgent`, и подагент работает только в рамках одного вызова. Сохраняйте новую терминологию при обновлении prompt-шаблонов.
